* There is no one, ultimate and correct way to write CSS. Sooner or later, CSS will make you miserable and will become hard to maintain (so exactly like with JavaScript, except that for JS it happens way faster).
* What's the problem with CSS?:
    - The main problem is the "C" in CSS - it's cascading. It's nice idea that the styles of some elements will inherit the styles of some other elements, but once you code grows bigger it actually starts getting in your way. You try to modify one element only to find out that you just broke 5 other pages.
    - Once your CSS starts growing, it gets harder to maintain. Specificity of some selectors gets in your way (especially if you are using some frameworks), so your CSS rules gets more and more complicated. Soon, that's not enough and you start using IDs or !important, just for the styling purposes.
    - The bigger the CSS file already is, the faster a duplicated or unused code starts appearing in there. Why? Let's say a developer needs to add a new button. There are already 10 different buttons but this one is different, so he creates a new class. Later someone decides that we need to normalize the look of the buttons and they decide to use only one style of buttons on the website. Maybe someone decides to remove the CSS for unused buttons, but it's possible that this code depended on some other CSS rules (because of siblings or children selectors) and you end up breaking things. So the old code stays, just in case. That's how you get the unused code. And how do you get duplicates? Imagine you have more than one person working on the CSS. Crazy, right? But it happens. So someone creates a class for a menu and names it 'menu'. The other developer needs to create a navigation on a different page and since there is no 'navigation' class, he creates one. And both the menu and navigation look pretty similar, but since there are more elements inside, they can't be merged into one element, so both versions stay. That's how you get the duplicated code.
* And it's not like with the programming languages, where you can refactor your code at any time. When you get assigned to a legacy project in let's say Java or Python that looks bad, you can start refactoring it with small steps and piece by piece, you will refactor the whole code base. For a huge legacy CSS, the best thing you can do is to rewrite it. There is no way to refactor this efficiently, especially if it's just a bunch of spaghetti rules without any general conception in mind (which is usually try for a lot of CSS.). And rewriting CSS from scratch is not something that any manager will let you do, unless you are redesigning the website.
* So what can we do with this problem?
    - The first idea would be to find a way to write tests for CSS. Since tests for programming languages will greatly help you refactoring it, the same should apply to CSS. You might be thinking - what the hell I mean by tests for CSS?
    - Well, each time you modify the CSS on your website, you will probably open a few pages to see if everything looks fine. If your website is supposed to be responsive, maybe you will resize the browser to see if everything looks fine on the mobile or a tablet. It's like playing this game when you have 2 pictures that look almost the same and your task is to find 5 differences. Except that you would be playing the same fucking game over and over again with different kind of changes. And this is a terribly tedious and boring task, not to mention that once you get more than few sub pages, you are likely to miss a bug or two only to notice them way later when you will have no idea what exactly broke it. A better idea would be to have a tool that will do this tedious work for us. And this is why the visual regression testing was invented.
    - Visual regression test takes a screenshot of your website or part of your website and after you make some modification and run the tests, it takes another screenshot of the same part of the website. Then it compares those 2 screenshots, pixel by pixel and if something is different, the test is failing, usually presenting you with a diff between these two images.
    - There are many tools for visual regression tests, starting from the most well known - PhantomCSS. In this case, you install it on your local machine, write some visual tests where you basically define the setup part like, logging in and filling some fields and then you tell it to take a screenshot. The screenshot will be saved as a baseline for future tests. Now, if you run the tests again, PhantomCSS will take another screenshot and compare it with the previous one. If there are some changes between the two screenshots, you will get a failing test. You can now decided if the change was expected (so the newest screenshot will replace the baseline image and will be used for the next comparisons) or you can go and modify the CSS if the change was unexpected.
    - Writing tests only for the visual regressions can be annoying (you already have to write unit, functional, integration, acceptance and god only know what kind of tests), so for some programming languages you can find tools that will allow you to integrate visual regression testing with you existing functional tests. For example, the spectre application is a nice diff tool that will allow you to send screenshots to comparison directly from your cucumber tests for rake tasks.
    - But what is a real kicker for me is a way to add visual regression testing as a part of your continuous integration cycle and that's possible with percy.io. You can easily integrate percy.io with Travis, Jenkins or other popular CI tools, it only supports Python, Ruby, and Ruby on Rails, Ember and static websites. It's a quite new tool but they already have many nice features like freezing animations. I have tried them before and there were some annoying bugs that they seems to fix recently, so I hope it's quite usable right now. Hopefully there will be more tools like that showing in the future.
    - I'm also listing two other tools for visual regression testing in Python if you want to take a look.
* Visual regressions testing sounds great but there are problems with it. If you don't like writing unit tests, then you will probably like writing regression tests even less. On top of the normal issues with tests which is that you have to update them over and over again, visual regressions have some other culprits.
    - Imagine you have a number somewhere on your website that can change (for example, the number of documents created by your user) or some blog posts that are selected by random. Well, then probably your tests will fail each time that number or that blog post changes. So you have to think carefully what you want to compare. Fortunately, most of the tools allow you to select what exactly you want to compare or even to ignore some parts of the website.
    - Now, for tools like PhantomCSS, where you don't actually include them as a part of some CI tests suite but you run it on your local machine - if you share it with your team, it's possible that the tests will fail only because a different OS and different graphic card now generates slightly different image. Also, it's possible that their machine will be configured differently and instead of using Chrome, they will have Chromium and that will also make your tests fail. A lot of those problems are solved by the CI tools like percy.
* So we have discussed how we can protect ourselves a bit, when modifying the CSS. Now, how can we actually write the CSS, so that it's easier to maintain it in the future? Well, there are a bunch of methodologies that were introduced to help you with that.
    - We have Object Oriented CSS that encourages you to separate the style from structure and to separate the container from the content. I will allow you to ....
    - Then we have BEM - Block Element Modifier methodology that on the first glance tells you how to name classes in CSS. It's actually more than that and after using it for a while I can generally recommend it as a nice way to write your CSS. It encourages you to think about the elements of your pages as of independent modules that can be nicely encapsulated and reused without much hassle.
    - We even have SMACSS which is scalable and modular architecture for CSS that basically tells you how to categorize CSS rules.
* All those methodologies are nice and definitely help you with writing CSS. But the fact that people keep coming up with methodologies to write CSS and those methodologies get popular means, that we obviously have a problem with CSS.
* So, recently, there was a yet another idea how to approach the CSS writing - a functional CSS. Since functional programming is now trendy (again), why can't the CSS be functional?
* So what does it mean a functional CSS? Let's take a look an some example.
    - We have a standard media object here - box with an image inside and some text description.
    - This is the HTML code for that element, if we would use one of the existing frameworks for functional CSS. That's a lot of code, isn't it? Ok, now, let's see the CSS that we use. Basically, every CSS class contains only one rule (except for rules for example for vertical margins, where you have two rules). Now, what's the point of writing CSS like that? It's pretty simple - we didn't have to write a single line of CSS to make this box looks as we want it. Now, if we decide that we want to increase the font size of the text, we just modify one class in the HTML snippet and we are done. No more going though the CSS and figuring out what rules you can change to make this happen without breaking something else.
* As you can see, functional CSS is:
    - Pure - there are no side effects of the functional CSS classes. You can be sure that a class that is supposed to set the background color just sets a fucking background color. Compare it with the standard CSS, where each class will change 10 properties and 5 more changes will be inherited from the parent, just so cascading can fuck you up.
    - Composable - just like in a functional programming, you are building your element from small, reusable blocks.
    - Immutable - when you use functional CSS, you are 100% sure that once you declare a property, nothing will overwrite it. You no longer have to fight with the specificity or actually have the specificity fuck you up later, when you don't pay attention.
    - Transparent - you know exactly what will happen if you apply a given class. That's why the functional CSS frameworks use the rem units instead of em. You know that, no matter where you put a given element on a page, if add class with 1 rem font size, it will have this exact font size.
* I don't advise you to write your functional CSS boilerplate from the scratch, that will take a lot of time. There are two main frameworks: Basscss and Tachyons for that. They differ slightly in the way they name classes but both are quite great and have a very good documentation. Documentation is very important when using a functional CSS. If you can't easily find a class that does a given thing, you will start duplicating code.
* Let's talk about good and bad parts of the functional CSS approach. And let's start from the bad parts. What are the problems with functional CSS?
    - The main argument against the functional CSS is that you are replacing duplicated CSS rules with duplicated CSS classes.
    - When you are writing CSS the standard way, you will have a lot of rules duplication and there is not much you can do with it.
    - When you switch to functional CSS, instead of duplicating the CSS rules, you will duplicate the CSS classes.
    - So instead of having a messy CSS files, we now have a messy HTML files, right? Well, not really. You can and you should create HTML components for the parts of you website that are repeated often. Every framework provides you with some way to create components, either with component elements, partials, mixing, widgets or whatever so that way you will have to write the HTML only once.
    - Updating existing components can be difficult. Imaging that your designer decides that we should change the font family of multiple elements and maybe add more margin to all buttons. With standard way of writing the CSS, if you separate the classes using some of the existing methodologies, you can just open the CSS files concerned with your changes and use find-replace to quickly apply your changes. With functional CSS, you will have to modify all the HTML components and replace the existing classes, which indeed can take more time.
    - And probably the biggest problem for many is that it won't work with Bootstrap or other non-functional CSS frameworks that give you a lot of styling out of the box. It's because Bootstrap relies heavily on the cascading property of CSS, while functional CSS completely ignores cascading. Bootstrap rules will usually have higher specificity than classes from Basscss or Tachyons, so the only way to make it work together would be to use !important on all functional classes.
* Now, the good parts.
    - Modifying the existing CSS is easy. You can modify the existing styling for HTML elements without the fear that you will break something. If you decide that a given image no longer needs to float to the right, you remove '.float-right' class instead of checking what class that image had, checking what other places use the same class and then deciding if it should be removed or not. If you remove a class or a CSS rule, you need to check other places if everything still works fine (remember, it's **cascading**, so there can be consequences that you won't easily see). Which means that more often than not, developers will decide to leave the old CSS code there. It results in big CSS files, full of unused rules.
    - You no longer have to fight with the specificity when you add a new rule just because a framework you have used had to chain 5 classes together to make something work.
    - And since all classes have the same specificity level (which is just one class) - it will make modifications way easier. For example, if you want to include the left-to-right support you just add another CSS file that will overwrite some of the rules related to the text direction. Or if you decide that you want to have different color themes for your website - you just include a small CSS file that overwrites some of the existing classes. Good luck doing that with bootstrap.
    - Once you learn the most common class names - and in most cases those are just simple abbreviations - you will be actually coding way faster. Let's say you need a div with small margin on top and black background? No problem, just add 2 classes to the HTML and you are done. You don't need to open a CSS class and figure out if you can reuse any of the existing classes, or if you should write a new one.
    - It encourages you to split your HTML into components (or partials/mixins/widgets/blocks/whatever) which will make your code DRY. Also, Tachyons come with the huge list of existing components that you can easily reuse.
    - When you change the styling by changing the CSS classes in the HTML, you won't have problems with invalidation the cache. While if you change the CSS rules in CSS files, you might actually cause you some problems with cache busting .
    - You might actually find out that after switching to functional CSS, you not only have less CSS files to download, but the overall size or your website went down, since you no longer duplicate the CSS rules. And that means your website will load faster.
* So, does it mean that we no longer have to write CSS with functional CSS? No, you will still write CSS for stuff that can't be reusable (for example a box with 42px margin, 158px padding and font size of 17px, that will be pixel-perfect but it won't be reusable at all). Also, in my opinion, if you really want to have CSS classes with a set of rules, nothing stops you. You can create a generic element that you know you won't change often (if you do change it often, then you are back to the problems that we just tried to solve by using the functional CSS) and you want to reuse in multiple places. For example, if you want a modal for your website, just create:
```
.modal {
    position: fixed;
    top: 50%;
    left: 50%;
    -webkit-transform: translate(-50%,-50%);
    -ms-transform: translate(-50%,-50%);
    transform: translate(-50%,-50%);
    *width: 600px;
    *margin-left: -300px;
    *top: 50px;
}
```
then if you need a bigger modal, just add 'width-50' class (as long as you don't bump the selectors specificity, you shouldn't get into many troubles). Or to actually make it better, just add the styles that you know you won't need to overwrite and the add the remaining styles with functional classes (so width, margin left and top will come from different classes).