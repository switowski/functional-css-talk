* I would like to introduce you to 2 concepts that might help writing maintainable CSS. One is the visual regression testing that will help you modify your CSS with confidence and the other is functional CSS that has some benefits over the standard way of writing the CSS. There is no one, ultimate and correct way to write CSS. Sooner or later, your CSS will probably become hard to maintain.
* What's the problem with CSS?:
    - The main problem is the "C" in CSS - it's cascading. It's nice idea that the styles of some elements will inherit the styles of some other elements because it can save you some typing, but once you code grows bigger it actually starts getting in your way. You try to modify one element only to find out that you just broke 5 other pages.
    - Once your CSS starts growing, it gets harder to maintain. Specificity of some selectors gets in your way (especially if you are using some frameworks), so your CSS rules gets more and more complicated. Soon, that's not enough and you start using IDs or !important, just for the styling purposes.
    - The bigger the CSS file already is, the faster a duplicated or unused code starts appearing in there. Why? Imagine you have more than one person working on the CSS. Crazy, right? But it happens. So someone creates a class for a menu and names it 'menu'. The other developer needs to create a navigation on a different page and since there is no 'navigation' class, he creates one. And both the menu and navigation look pretty similar, but since there have slightly different layout of elements inside, they can't be merged into one element, so both versions stay. Or some developers use only classes for styling the CSS but other developers use tags and it's not easy to see the duplication of styling right away. And come on, no one does code reviews of CSS. If we don't use automatic tools to spot the duplicates, there is no way a human being will be able to do this.
    - So that's why we get the duplicates, and how do we end up with unused code? Some CSS rules will get complicated and they will depend on some other CSS rules because the selectors are chained together or because of the cascading. When you try to remove something, something else will break. So you know what most developers will do in this case? They will leave those CSS classes there, because they can. Nothing bad will happen if you don't remove CSS rules from a CSS files and you can move on with your work because you have deadlines.
* And it's not like with the programming languages, where you can refactor your code at any time. When you get assigned to a legacy project in let's say Java or Python that looks bad - so let's say it's Java - you can start refactoring it with small steps and piece by piece, you will refactor the whole code base. For a huge legacy CSS, the best thing you can do is to rewrite it. There is no way to refactor this efficiently, especially if it's just a bunch of spaghetti rules without any general conception in mind (which is usually true for a lot of CSS.). And rewriting CSS from scratch is not something that any manager will let you do, unless you are redesigning the website.
* So what can we do with this problem?
    - The first idea would be to find a way to write tests for CSS. Since tests for programming languages will greatly help you refactoring it, the same should apply to CSS. You might be thinking - what the hell I mean by tests for CSS? I don't mean tests that will check if a given element has a class or a specific rule. Your website can still look like crap even though some arbitrary elements that you decided to check have specific CSS rules. No, I mean actually testing how the website looks. Each time you modify the CSS on your website, you will probably open a few pages to see if everything looks fine. If your website is supposed to be responsive, maybe you will resize the browser to see if everything looks fine on the mobile or a tablet.
    - It's like playing this game when you have 2 pictures that look almost the same and your task is to find 5 differences. Except that you would be playing the same game over and over again with different kinds of changes. And this is a terribly tedious and boring task, not to mention that once you get more than few sub pages, you are likely to miss a bug or two only to notice them way later when you will have no idea what exactly broke it. Since human are not really good at this game, let's have machines play it. That's where the visual regression testing comes in.
    - Visual regression test takes a screenshot of your website or part of your website and after you make some modification and run the tests, it takes another screenshot of the same part of the website. Then it compares those 2 screenshots, pixel by pixel and if something is different, the test is failing, usually presenting you with a diff between these two images.
    - There are many tools for visual regression tests, starting from the most well known - PhantomCSS. In this case, you install it on your local machine, write some visual tests where you basically define the setup part like, logging in and filling some fields and then you tell it to take a screenshot. The screenshot will be saved as a baseline for future tests. Now, if you run the tests again, PhantomCSS will take another screenshot and compare it with the previous one. If there are some changes between the two screenshots, you will get a failing test. You can now decided if the change was expected (so the new screenshot will replace the baseline image and will be used for the next comparisons) or you can go back and modify the CSS if the change was unintended.
    - Writing tests only for the visual regressions can be annoying (you already have to write unit, functional, integration, acceptance and god only know what kind of tests), so for some programming languages you can find tools that will allow you to integrate visual regression testing with you existing functional tests. For example, if you are using the cucumber testing framework, which supports many programming languages, there is a spectre application that is a nice diff tool that will allow you to send screenshots to comparison directly from your cucumber tests.
    - But what is a real kicker for me is a way to add visual regression testing as a part of your continuous integration cycle and that's possible with percy.io. You can easily integrate percy.io with Travis, Jenkins or other popular CI tools, and it supports Python, Ruby, and Ruby on Rails, Ember and static websites. It's a quite new tool but they already have many nice features like freezing animations. I have tried them before and there were some annoying bugs that they seems to fix recently, so I hope it's quite usable right now. Hopefully there will be more tools like that in the future.
    - I'm also listing two other tools for visual regression testing in Python if you want to take a look.
* Visual regressions testing sounds great but there are problems with it. If you don't like writing unit tests, then you will probably enjoy writing regression tests even less. On top of the normal issues with tests which is that you have to update them over and over again, visual regressions have some other culprits.
    - Imagine you have a number somewhere on your website that can change (for example, the number of documents created by your user) or some blog posts that are randomly selected. Well, then probably your tests will fail each time that number or that blog post changes. So you have to think carefully what you want to compare. Fortunately, most of the tools allow you to select what exactly you want to compare or even to ignore some parts of the website.
    - Now, for tools like PhantomCSS, where you don't actually include them as a part of some CI tests suite but you run it on your local machine - if you share the screenshots it with your team, it's possible that the tests will fail only because a different OS and different graphic card now generates slightly different image. Also, it's possible that their machine will be configured differently and instead of using Chrome, they will have Chromium and that will also make your tests fail. A lot of those problems are solved by the CI tools like percy.
* So we have discussed how we can protect ourselves a bit, when modifying the CSS. Now, how can we actually write the CSS, so that it's easier to maintain  in the future? Well, there are a bunch of methodologies that were introduced to help you with that.
    - We have the Object Oriented CSS that boils down to 2 main rules. You should separate the style from structure. What it means is that you should create separate classes for the structure that will define how the button or a modal looks like and separate classes for the skin of those elements like an alert button will have a red color and info button will have blue. If you use frameworks like Bootstrap, you should be familiar with this pattern as this is exactly what Bootstrap is doing. Second rule - separate container and content means that an element should look the same, no matter where it's located in the website. So don't style tags, style classes.
    - Then we have BEM - a methodology that encourages you to think about the HTML and CSS in 3 categories: blocks, elements and modifiers. Any independent element of your website is a block, like the menu bar. All the pieces of code that live inside that block and don't make much sense outside of it are Elements, for example menu elements that live inside the menu block. And if you need to apply some modifications to the block or the element, for example, one of the menu items should be active, you use the modifier. Very simple, but after using it for a while, I can say that it's super efficient. In greatly improves the encapsulation and reusability of your CSS.
    - If you need an even more fine-grained categorization of the elements, you can follow the SMACSS methodology that encourages you to split the CSS classes into 5 different categories: base, layout, module, state and theme. Although I have no experience using this one, so I can't say how it works in practice.
* All those methodologies are nice and definitely help you with writing CSS. But the fact that people keep coming up with methodologies to write CSS and those methodologies get popular means, that we obviously have a problem with CSS.
* So, recently, there was a yet another idea how to approach the CSS writing - a functional CSS. Since functional programming is now trendy (again), why can't the CSS be functional?
* So how does a functional CSS works? Let's take a look an some example.
    - We have a standard media object here - box with an image inside and some text description.
    - This is the HTML code for that element, if we would use one of the existing frameworks for functional CSS. That's a lot of code, isn't it? Ok, now, let's see the CSS that we use.
    - Wow, that's even more code. But I tell you what. Do you know how many lines of CSS did I have to write when creating this box with image and text? Exactly 0. All of that CSS comes from a framework (I don't have to use an existing framework, I can write one for myself and that will work just fine). As you can see, basically, every CSS class contains only one rule (except for classes for example for vertical margins, where you have two rules). Thanks to that, once I have all the rules in place, I don't have to write CSS anymore for styling any elements on the page.
    - Now, if we decide that we want to increase the font size of the text, we just modify one class in the HTML snippet and we are done. No more going though the CSS and figuring out what rules you can change and how to make this happen without breaking something else.
* As you can see, functional CSS is:
    - Pure - there are no side effects of the functional CSS classes. You can be sure that a class that is supposed to set the background color just sets a fucking background color. Compare it with the standard CSS, where each class will change 10 properties and 5 more changes will be inherited from the parent, just so cascading can fuck you up.
    - Composable - just like in a functional programming, you are building your element from small, reusable blocks.
    - Immutable - when you use functional CSS, you are 100% sure that once you declare a property, nothing will overwrite it. You no longer have to fight with the specificity.
    - Transparent - you know exactly what will happen if you apply a given class. That's why the functional CSS frameworks use the rem units instead of em. You know, that no matter where you put a given element on a page, if you add class with 1 rem font size, it will have this exact font size.
* I don't recommend writing your own functional CSS boilerplate from the scratch, it will take a lot of time. There are two main frameworks than you can use: Tachyons and Basscss. They differ slightly in the way they name classes but both are quite great and have a very good documentation. Documentation is very important when using a functional CSS. If you can't easily find a class that does a given thing, you will start duplicating code.
* Let's talk about good and bad parts of the functional CSS approach. What can you gain by writing functional CSS?
    - Modifying the existing styling is easy. You can modify styles for HTML elements without the fear that you will break something. If you decide that a given image no longer needs to float to the right, you remove '.float-right' class instead of checking what class that image had, checking what other places use the same class and then deciding if it should be removed or not. If you remove a class or a CSS rule, you need to check other places if everything still works fine (remember, it's **cascading**, so there can be consequences that you won't easily see). Which means that more often than not, developers will decide to leave the old CSS code there. It results in big CSS files, full of unused rules.
    - You no longer have to fight with the specificity when you add a new rule just because Bootstrap had to chain 5 classes together to make something work.
    - And since all classes have the same specificity level (which is just one class) - it will make modifications way easier. For example, if you want to include the right-to-left support you just add another CSS file that will overwrite some of the rules related to the text direction. Or if you decide that you want to have different color themes for your website - you just include a small CSS file that overwrites some of the existing classes. Good luck writing a template for Bootstrap.
    - Once you learn the most common class names - and in most cases those are just simple abbreviations - you will be actually coding way faster. Let's say you need a div with small margin on top and black background? No problem, just add 2 classes to the HTML and you are done. You don't need to open a CSS file and figure out if you can reuse any of the existing classes, or if you should write a new one.
    - If you have to write the same set of classes over and over again, you will quickly get bored and you will probably create an HTML component to reuse or a partial/mixin/widget/block/whatever. And this is good, it makes you code DRY. Also, Tachyons come with the huge list of existing components that you can easily reuse.
    - It also encourages a design consistency. Before you start working on a new project, you can go through the clean framework and adjust all settings according to the design vision. You will probably set the different heading sizes according to some typeset tools, make the different margin sizes consistent, etc. Then, you will start coding and you no longer will have to think how many pixels you need for margins. You will have a set of classes with available margins that are properly scaled beforehand and you will choose from those. You are no longer distracted with the small design decisions when coding.
    - When you change the styling by changing the CSS classes in the HTML, you won't have problems with invalidation the cache. While if you change the CSS rules in CSS files, it might actually cause you some problems with cache busting.
    - You might actually find out that after switching to functional CSS, you not only have less CSS files to download, but the overall size of your website went down, since you no longer duplicate the CSS rules. And that means your website will load faster.
* Now, the bad parts:
    - The main argument against the functional CSS is that you are replacing duplicated CSS rules with duplicated CSS classes.
    - When you are writing CSS the standard way, you will have a lot of rules duplication and there is not much you can do with it.
    - When you switch to functional CSS, instead of duplicating the CSS rules, you will duplicate the CSS classes.
    - So instead of having a messy CSS files, we now have a messy HTML files, right? Well, not really. You can and you should create HTML components for the parts of your website that are repeated often. Every framework provides you with some way to create components, either with component elements, partials, mixing, widgets or whatever so that way you will have to write the HTML only once.
    - Updating existing components can be difficult. Imagine that your designer decides that we should change the font family of multiple elements and maybe add more margin to all buttons. With standard way of writing the CSS, if you separate the classes using some of the existing methodologies, you can just open the CSS files concerned with your changes and use find-replace to quickly apply your changes. With functional CSS, you will have to modify all the HTML components and replace the existing classes, which indeed can take more time.
    - And probably the biggest problem for many developers is that it won't work with Bootstrap or other non-functional CSS frameworks that give you a lot of styling out of the box. It's because Bootstrap relies heavily on the cascading property of CSS, while functional CSS completely ignores cascading. Bootstrap rules will usually have higher specificity than classes from Basscss or Tachyons, so the only way to make it work together would be to use !important on all functional classes.
* So, does it mean that we no longer have to write CSS with functional CSS?
    - No, you will still write CSS for stuff that can't be reusable (for example a button with 47px margin, 153px padding and font size of 18px, that will be pixel-perfect but it won't be reusable at all).
    - And Functional CSS is not a religion, it's a tool. In my opinion, if you really want to have CSS classes with a set of rules instead of HTML components, nothing stops you. You can create a CSS for a generic element that you know it won't change often and you want to reuse in multiple places. For example, if you want a modal for your website, just create this modal class. Then if you need a bigger modal, just add 'width-50' class. If you put the CSS in a correct order and you don't increase the selectors specificity, you shouldn't get into many problems. Or to actually make it better, just add the styles that you know you won't need to overwrite and then add the remaining styles with functional classes (so width, margin left and top will come from different classes).
* Functional CSS is not a silver bullet (there are no silver bullets in CSS, there are just less painful ways of doing stuff), but it might solve some of the problems that you have.
* At the end when it comes to CSS it all boils down to the "CSS bloat vs HTML bloat" since you data has to live somewhere. At some point you will have to make a choice between one of those two solutions and which one you prefer, it's up to you.